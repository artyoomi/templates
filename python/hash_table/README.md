## Associative array

В данном случае ассоциативный массив представлен в виде **хэш-таблицы**. Для **хэширования** использована встроеная в Python функция ```hash()```.
**Коллизии** обрабатываются методом цепочек. В реализации функционала старался походить на оригинальную реализацию ```dict()``` из Python (умные дядьки скорее всего плохого не придумают).

### Интерфейс класса
- ```htable[key]``` - реализовано с помощью метода ```__setitem__```. Если ключ уже присутствует в таблице, то его
значение просто заменяется;
- ```htable[key]``` - получение значения по ключу, реализовано с помощью метода ```__getitem__```. Если ключа ```key``` нет в таблице, выбрасывается исключение;
- ```pop(key)``` - удаление значения по ключу. Возвращает удалённый ключ или выбрасывает ошибку, если ключ не был найден;
- ```get(key, default_value=None)``` - аналог ```get()``` словаря из стандартной бибилотеки. Возвращает значение, если оно было найдено в словаре. Иначе возвращается ```default_value```;
- ```items()``` - получение пар ключ-значение;
- ```keys()``` - получение ключей хэш-таблицы;
- ```capacity()``` - геттер для получения текущей вместимости хэш-таблицы;
- ```clear()``` - метод для очистки хэш-таблицы;
- ```__len__``` - для получения длины хэш-таблицы с помощью ```len()```;
- ```__str__``` - для получения строкового представления хэш-таблицы;
- ```__contains__``` - для возможности использования оператора ```in```.

Хэш-таблица умеет изменять свой размер при достижении определённой границы (```0.75``` в данном случае). После достижения порогового уровня заполнения, происходит изменение размера таблицы.
Таблица сохраняет все свои значения в отдельный список и заново перезаполняет список ```self._data```.

### Обоснование выбора
- **Хэш-функция:** в задании не было сказано, какие данные должны храниться в хэш-таблице, поэтому встроенная функция ```hash()``` подходит для реализвации хэширования лучше всего.
Для всех встроенных неизменяемых типов функция ```hash()``` корректно определена и протестирована, это значительно лучше чем самописная функция, которая будет иметь кучу коллизий. К тому же
это позволяет унифицировать хэширование. *Например: появляется возможность без изменения реазилации хранить в хэш-таблице собственные типы данных, у которых переопределена функция ```__hash__()```*;
- **Метод разрешения коллизий:** так как используется хорошая хэш-функция, то здесь отлично подходит *метод цепочек*. Это так, потому что коллизий ожидается немного, а это значит что в цепочках
будет достаточно мало элементов. Это с одной стороны позволит избежать ```O(n)``` поиска в цепочках, а с другой достаточно быстро решать коллизии.
