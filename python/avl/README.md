## AVL tree

This is same AVL tree implementation as introduced in templates for C++.

### Class interface
- ```height()``` - получение высоты дерева;
- ```insert(key)``` - добавить новое значение в дерево;
- ```remove(key)``` - удалить по ключу узел из дерева;
- ```remove_min()``` - удалить минимальный элемент из дерева;
- ```remove_max()``` - удалить максимальный элемент из дерева;
- ```min()``` - получить минимальный элемент в дереве;
- ```max()``` - получить максимальный элемент в дереве;
- ```data(order=["in", "pre", "post", "width"])``` - получить ключи дерева. Порядок обхода зависит от переданного параметра ```order```;
- ```raw()``` - получить "сырой" указатель на корень дерева;
- ```count(key)``` - посчитать количество узлов дерева, у которых ключ равен ```key```;
- ```split(key)``` - разделить дерево на два дерева по ключу ```key```, ```key``` не входит ни в одни из возвращаемых массивов. Возвращает два новых дерева, исходное дерево остаётся нетронутым;
- ```validate()``` - валидация дерева: проверка на AVL, проверка на BST;
- ```clear()``` - удаляет все элементы из дерева;
- ```__len__()``` - получение количества элементов в дереве;
- ```__contains__()``` - для возможности проверки принадлежности оператором ```in```;
- ```__bool__()``` - возвращает True, если дерево пусто, иначе False;
- ```__add__()``` - слияние двух деревьев в одно. Возвращает новое дерево, являющееся суммой двух переданных (исходные деревья остаются неизменными);
- ```__deepcopy__()``` - глубокое копирование дерева.

### Реализация
В целом это стандартная реализация AVL дерева, где всё, что возможно, было переиспользовано (*например, в ```remove_min()``` узел с минимумом находится с помощью _run_remove_min(), который
в свою очередь ищет узел с минимумом с помощью ```_min()```*).
Для ```split``` используется алгоритм, который работает за ```O(log(n))```, a ```merge``` за ```O(mlog(n + m))```.
